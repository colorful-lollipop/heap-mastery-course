#include "exploit_utils.h"
#include "debug_utils.h"
#include <string.h>

// Get the chunk size field (includes metadata)
size_t get_chunk_size_field(void *ptr) {
    if (ptr == NULL) return 0;

    // ptr points to user data, chunk header is 0x10 bytes before
    chunk_info_t *chunk = (chunk_info_t *)((char *)ptr - 0x10);
    return chunk->size;
}

// Set chunk size field
void set_chunk_size_field(void *ptr, size_t size) {
    if (ptr == NULL) return;

    chunk_info_t *chunk = (chunk_info_t *)((char *)ptr - 0x10);
    chunk->size = size;
}

// Get pointer to actual data portion of chunk
void *get_chunk_data_ptr(void *chunk) {
    if (chunk == NULL) return NULL;
    return (char *)chunk + 0x10;
}

// Get usable size (size minus header)
size_t get_usable_size(void *ptr) {
    size_t chunk_size = get_chunk_size_field(ptr);
    return chunk_size - 0x10;
}

// Align address to given alignment
void *align_address(void *addr, size_t alignment) {
    uintptr_t a = (uintptr_t)addr;
    return (void *)((a + alignment - 1) & ~(alignment - 1));
}

// Check if address is aligned
int is_aligned(void *addr, size_t alignment) {
    uintptr_t a = (uintptr_t)addr;
    return (a & (alignment - 1)) == 0;
}

// Arbitrary write primitive (for educational purposes)
void arbitrary_write(void *addr, uint64_t value) {
    DEBUG_WARNING("Arbitrary write to %p: 0x%lx", addr, value);

    // In real exploitation, this would be done via heap vulnerability
    // For educational purposes, we directly write
    *(uint64_t *)addr = value;
}

// Arbitrary read primitive (for educational purposes)
uint64_t arbitrary_read(void *addr) {
    DEBUG_WARNING("Arbitrary read from %p", addr);

    // In real exploitation, this would be done via heap vulnerability
    // For educational purposes, we directly read
    return *(uint64_t *)addr;
}

// Execute shellcode (for educational purposes only)
void execute_shellcode(void *shellcode) {
    DEBUG_ERROR("Shellcode execution is for educational purposes only!");
    DEBUG_ERROR("This should NEVER be used on systems you don't own!");

    // Cast to function pointer and execute
    void (*func)(void) = (void (*)(void))shellcode;
    func();
}

// Get address of shellcode in memory
void *get_shellcode_addr(void) {
    // This would return the address of shellcode in memory
    // In real exploits, shellcode would be sprayed in heap
    return NULL;
}
